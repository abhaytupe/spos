											Shortest Job First(SJF)

def sjf():
    n = int(input("Enter number of processes: "))
    processes = []

    for i in range(n):
        at = int(input(f"Arrival time of P{i+1}: "))
        bt = int(input(f"Burst time of P{i+1}: "))
        processes.append([f"P{i+1}", at, bt])

    # Sort initially by arrival time
    processes.sort(key=lambda x: x[1])

    time = 0
    completed = 0
    done = [False] * n
    total_tat = total_wt = 0

    print("\nProcess\tAT\tBT\tCT\tTAT\tWT")

    while completed < n:
        # Find all processes that have arrived
        ready = [p for p in processes if p[1] <= time and not done[processes.index(p)]]

        if ready:
            # Pick the process with the smallest burst time
            p = min(ready, key=lambda x: x[2])
            i = processes.index(p)

            time += p[2]
            ct = time
            tat = ct - p[1]
            wt = tat - p[2]

            total_tat += tat
            total_wt += wt
            done[i] = True
            completed += 1

            print(f"{p[0]}\t{p[1]}\t{p[2]}\t{ct}\t{tat}\t{wt}")
        else:
            # If no process has arrived yet, move time forward
            time += 1

    print(f"\nAverage TAT = {total_tat/n:.2f}")
    print(f"Average WT = {total_wt/n:.2f}")

# Run program
sjf()

